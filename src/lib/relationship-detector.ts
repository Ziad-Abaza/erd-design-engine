import { Edge, Node } from 'reactflow';
import { Column, TableNodeData } from '@/components/editor/nodes/table-node';

export interface JunctionTable {
  id: string;
  name: string;
  sourceTable: string;
  targetTable: string;
  sourceColumn: string;
  targetColumn: string;
  isAutoGenerated: boolean;
}

export interface Relationship {
  id: string;
  sourceTable: string;
  sourceColumn: string;
  targetTable: string;
  targetColumn: string;
  cardinality: '1:1' | '1:N' | '0:1' | '0:N' | 'N:M';
  onDelete?: 'CASCADE' | 'SET NULL' | 'RESTRICT';
  onUpdate?: 'CASCADE' | 'SET NULL' | 'RESTRICT';
  junctionTable?: string;
}

export interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

export class RelationshipDetector {
  static detectJunctionTables(nodes: Node[]): JunctionTable[] {
    const junctionTables: JunctionTable[] = [];

    nodes.forEach(node => {
      if (node.type === 'junctionTable') {
        const data = node.data as {
          label: string;
          sourceTable: string;
          targetTable: string;
          sourceColumn: string;
          targetColumn: string;
          isAutoGenerated?: boolean;
        };
        junctionTables.push({
          id: node.id,
          name: data.label,
          sourceTable: data.sourceTable,
          targetTable: data.targetTable,
          sourceColumn: data.sourceColumn,
          targetColumn: data.targetColumn,
          isAutoGenerated: data.isAutoGenerated || false
        });
      }
    });

    return junctionTables;
  }

  static detectManyToManyRelationships(nodes: Node[]): Relationship[] {
    const junctionTables = this.detectJunctionTables(nodes);
    const manyToManyRelationships: Relationship[] = [];

    junctionTables.forEach(junction => {
      // Create N:M relationship between source and target tables
      const relationship: Relationship = {
        id: `nm_${junction.sourceTable}_${junction.targetTable}`,
        sourceTable: junction.sourceTable,
        sourceColumn: junction.sourceColumn,
        targetTable: junction.targetTable,
        targetColumn: junction.targetColumn,
        cardinality: 'N:M',
        junctionTable: junction.name
      };

      manyToManyRelationships.push(relationship);
    });

    return manyToManyRelationships;
  }
  static detectRelationships(nodes: Node<TableNodeData>[]): Relationship[] {
    const relationships: Relationship[] = [];
    const tableMap = new Map<string, Node<TableNodeData>>();

    // Create a map of table names to nodes for easy lookup
    nodes.forEach(node => {
      tableMap.set(node.data.label.toLowerCase(), node);
    });

    // Detect many-to-many relationships from junction tables
    const manyToManyRels = this.detectManyToManyRelationships(nodes);
    relationships.push(...manyToManyRels);

    // Scan each table for foreign key columns with explicit references
    nodes.forEach(sourceNode => {
      sourceNode.data.columns.forEach(column => {
        if (column.isForeignKey) {
          // First try to find explicit foreign key reference information
          const explicitRef = this.findExplicitReference(sourceNode, column, nodes);

          if (explicitRef) {
            relationships.push(explicitRef);
          } else {
            // Fallback to inference from column name convention
            const targetTableName = this.inferTargetTable(column.name, Array.from(tableMap.keys()));

            if (targetTableName && tableMap.has(targetTableName)) {
              const targetNode = tableMap.get(targetTableName)!;
              const targetColumn = this.findTargetColumn(column, targetNode.data.columns);

              if (targetColumn) {
                const relationship: Relationship = {
                  id: `${sourceNode.id}-${targetNode.id}-${column.name}`,
                  sourceTable: sourceNode.data.label,
                  sourceColumn: column.name,
                  targetTable: targetNode.data.label,
                  targetColumn: targetColumn.name,
                  cardinality: this.determineCardinality(column, targetColumn),
                };

                relationships.push(relationship);
              }
            }
          }
        }
      });
    });

    return relationships;
  }

  static relationshipsToEdges(relationships: Relationship[], nodes: Node[]): Edge[] {
    return relationships.map(rel => {
      const edgeType = rel.cardinality === 'N:M' ? 'manyToMany' : 'relationship';
      const sourceId = rel.sourceTable.toLowerCase().replace(/\s+/g, '_');
      const targetId = rel.targetTable.toLowerCase().replace(/\s+/g, '_');

      // Attempt to find nodes and column IDs for handles
      const sourceNode = nodes.find(n => n.id === sourceId || n.data.label.toLowerCase() === rel.sourceTable.toLowerCase());
      const targetNode = nodes.find(n => n.id === targetId || n.data.label.toLowerCase() === rel.targetTable.toLowerCase());

      let sourceHandle = undefined;
      let targetHandle = undefined;

      if (sourceNode) {
        const col = sourceNode.data.columns.find((c: Column) => c.name === rel.sourceColumn);
        if (col) sourceHandle = `${sourceNode.id}-${col.id}-source`;
      }

      if (targetNode) {
        const col = targetNode.data.columns.find((c: Column) => c.name === rel.targetColumn);
        if (col) targetHandle = `${targetNode.id}-${col.id}-target`;
      }

      return {
        id: rel.id,
        source: sourceId,
        target: targetId,
        sourceHandle,
        targetHandle,
        type: edgeType,
        data: {
          relationship: rel,
          label: `${rel.sourceColumn} â†’ ${rel.targetColumn}`,
          cardinality: rel.cardinality,
          isValid: true,
          hasJunctionTable: !!rel.junctionTable,
        },
        animated: rel.cardinality === 'N:M' ? true : false,
        style: {
          strokeWidth: rel.cardinality === 'N:M' ? 3 : 2,
          stroke: rel.cardinality === 'N:M' ? '#8b5cf6' : '#3b82f6',
        },
      };
    });
  }

  static validateAndHighlightEdges(nodes: Node<TableNodeData>[], edges: Edge[]): Edge[] {
    const validation = this.validateRelationships(nodes, edges);

    return edges.map(edge => {
      const isValid = validation.isValid && !validation.errors.some(error =>
        error.includes(edge.id) || error.includes(edge.source) || error.includes(edge.target)
      );

      return {
        ...edge,
        data: {
          ...edge.data,
          isValid,
        },
        style: {
          ...edge.style,
          stroke: isValid ? '#3b82f6' : '#ef4444',
          strokeWidth: isValid ? 2 : 3,
        },
        animated: !isValid,
      };
    });
  }

  static validateRelationships(nodes: Node<TableNodeData>[], edges: Edge[]): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    const tableMap = new Map<string, Node<TableNodeData>>();
    nodes.forEach(node => {
      tableMap.set(node.data.label.toLowerCase(), node);
    });

    edges.forEach(edge => {
      const sourceNode = nodes.find(n => n.id === edge.source);
      const targetNode = nodes.find(n => n.id === edge.target);

      if (!sourceNode || !targetNode) {
        errors.push(`Edge ${edge.id} references non-existent table (source: ${edge.source}, target: ${edge.target})`);
        return;
      }

      // Check if foreign key columns exist
      if (edge.data?.relationship) {
        const rel = edge.data.relationship as Relationship;
        const sourceColumn = sourceNode.data.columns.find(c => c.name === rel.sourceColumn);
        const targetColumn = targetNode.data.columns.find(c => c.name === rel.targetColumn);

        if (!sourceColumn) {
          errors.push(`Source column ${rel.sourceColumn} not found in table ${rel.sourceTable}`);
        }
        if (!targetColumn) {
          errors.push(`Target column ${rel.targetColumn} not found in table ${rel.targetTable}`);
        }

        // Check if target column is a primary key
        if (targetColumn && !targetColumn.isPrimaryKey) {
          warnings.push(`Target column ${rel.targetColumn} in table ${rel.targetTable} is not a primary key`);
        }
      } else {
        // For manually created edges without relationship data
        warnings.push(`Edge ${edge.id} has no relationship data`);
      }
    });

    // Check for tables without primary keys
    nodes.forEach(node => {
      const hasPrimaryKey = node.data.columns.some(col => col.isPrimaryKey);
      if (!hasPrimaryKey) {
        warnings.push(`Table ${node.data.label} does not have a primary key`);
      }
    });

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
    };
  }

  private static findExplicitReference(
    sourceNode: Node<TableNodeData>,
    column: Column,
    nodes: Node<TableNodeData>[]
  ): Relationship | null {
    // 1. Check if column already has explicit reference metadata from SQL parsing
    if (column.referencedTable && column.referencedColumn) {
      const targetNode = nodes.find(n =>
        n.data.label.toLowerCase() === column.referencedTable?.toLowerCase()
      );

      if (targetNode) {
        const targetColumn = targetNode.data.columns.find(c =>
          c.name.toLowerCase() === column.referencedColumn?.toLowerCase()
        );

        if (targetColumn) {
          return {
            id: `${sourceNode.id}-${targetNode.id}-${column.name}`,
            sourceTable: sourceNode.data.label,
            sourceColumn: column.name,
            targetTable: targetNode.data.label,
            targetColumn: targetColumn.name,
            cardinality: this.determineCardinality(column, targetColumn),
          };
        }
      }
    }

    // 2. Check if column name suggests a specific reference (heuristic)
    const patterns = [
      /^(.*)_id$/,           // user_id -> users
      /^(.*)_fk$/,           // user_fk -> users
      /^(.*)_uuid$/,         // user_uuid -> users
      /^id_(.*)$/,           // id_user -> users
    ];

    for (const pattern of patterns) {
      const match = column.name.match(pattern);
      if (match) {
        const tableName = match[1];
        const targetNode = nodes.find(n =>
          n.data.label.toLowerCase() === tableName.toLowerCase() ||
          n.data.label.toLowerCase() === `${tableName}s`.toLowerCase()
        );

        if (targetNode) {
          const targetColumn = this.findTargetColumn(column, targetNode.data.columns);
          if (targetColumn) {
            return {
              id: `${sourceNode.id}-${targetNode.id}-${column.name}`,
              sourceTable: sourceNode.data.label,
              sourceColumn: column.name,
              targetTable: targetNode.data.label,
              targetColumn: targetColumn.name,
              cardinality: this.determineCardinality(column, targetColumn),
            };
          }
        }
      }
    }

    return null;
  }

  private static inferTargetTable(columnName: string, tableNames: string[]): string | null {
    // Common naming conventions for foreign keys
    const patterns = [
      /^(.*)_id$/,           // user_id -> users
      /^(.*)_fk$/,           // user_fk -> users
      /^(.*)_uuid$/,         // user_uuid -> users
      /^id_(.*)$/,           // id_user -> users
    ];

    for (const pattern of patterns) {
      const match = columnName.match(pattern);
      if (match) {
        const tableName = match[1];
        // Try exact match first
        if (tableNames.includes(tableName)) {
          return tableName;
        }
        // Try plural form
        const pluralName = tableName.endsWith('s') ? tableName : `${tableName}s`;
        if (tableNames.includes(pluralName)) {
          return pluralName;
        }
      }
    }

    return null;
  }

  private static findTargetColumn(sourceColumn: Column, targetColumns: Column[]): Column | null {
    // First try to find a primary key with the same name
    const pkMatch = targetColumns.find(col =>
      col.isPrimaryKey && col.name === sourceColumn.name
    );
    if (pkMatch) return pkMatch;

    // Then try common primary key names
    const commonPKNames = ['id', 'uuid', 'pk'];
    for (const pkName of commonPKNames) {
      const pk = targetColumns.find(col => col.isPrimaryKey && col.name === pkName);
      if (pk) return pk;
    }

    // Finally, return any primary key
    return targetColumns.find(col => col.isPrimaryKey) || null;
  }

  private static determineCardinality(sourceColumn: Column, targetColumn: Column): '1:1' | '1:N' | '0:1' | '0:N' | 'N:M' {
    const isUnique = sourceColumn.isUnique;
    const isNullable = sourceColumn.isNullable;

    if (isUnique) {
      return isNullable ? '0:1' : '1:1';
    } else {
      return isNullable ? '0:N' : '1:N';
    }
  }
}
